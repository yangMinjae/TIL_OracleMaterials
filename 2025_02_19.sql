CREATE TABLE DEPT_COPY AS SELECT * FROM DEPT;
CREATE TABLE EMP_COPY AS SELECT * FROM EMP;
SELECT * FROM DEPT_COPY;
CREATE VIEW EMP_VIEW30 AS SELECT EMPNO, ENAME, DEPTNO FROM EMP_COPY WHERE DEPTNO=30;

SELECT * FROM EMP_VIEW30;       -- 우리는 이게 뷰인지 테이블인지 모름
CREATE VIEW EMP_VIEW20 AS SELECT EMPNO, ENAME, DEPTNO, MGR FROM EMP_COPY WHERE DEPTNO= 20;
SELECT * FROM EMP_VIEW20;

SELECT VIEW_NAME, TEXT FROM USER_VIEWS;       -- 존재하는 뷰의 이름을 보여줌, 물리적인 테이블을 저장하진 않고, 서브쿼리형태로 저장하고 있다.
SELECT TABLE_NAME FROM USER_TABLES;     -- 처럼

INSERT INTO EMP_VIEW30 VALUES(1111, 'AAAA', 30);
SELECT * FROM EMP_COPY;             -- 뷰에 인서트를 했는데 원본 테이블에 들어감

INSERT INTO EMP_VIEW30 VALUES(8000, '김천사', 30);
SELECT * FROM EMP_COPY;

CREATE OR REPLACE VIEW EMP_VIEW(사원번호, 사원명, 급여, 부서번호) AS SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP_COPY;
SELECT * FROM EMP_VIEW WHERE 부서번호 = 30;
--SELECT * FROM EMP_VIEW WHERE DEPTNO = 30;     -- 동작 안함 뷰에 접근할때는 테이블이 아닌 뷰의 컬럼명으로 접근해야함.

CREATE VIEW VIEW_SAL AS SELECT DEPTNO, SUM(SAL) AS "SalSum", ROUND(AVG(SAL),2) AS "SalAvg" FROM EMP_COPY GROUP BY DEPTNO;
DROP VIEW VIEW_SAL;
SELECT * FROM VIEW_SAL;

-- 13- 문제2)

CREATE VIEW SAL_VIEW AS SELECT DNAME, MAX(SAL) "MAX_SAL", MIN(SAL) "MIN_SAL" FROM EMP_COPY JOIN DEPT_COPY USING(DEPTNO) GROUP BY DEPTNO, DNAME;
SELECT * FROM SAL_VIEW;

SELECT ROWID, ROWNUM, EMPNO, ENAME, HIREDATE FROM EMP;
SELECT ROWNUM, HIREDATE FROM EMP ORDER BY HIREDATE;

CREATE OR REPLACE VIEW VIEW_HIRE AS SELECT EMPNO, ENAME, HIREDATE FROM EMP ORDER BY HIREDATE;
SELECT * FROM VIEW_HIRE;
SELECT ROWNUM, EMPNO, ENAME, HIREDATE FROM VIEW_HIRE;   -- ROWNUM 쓸때는 * 불가
SELECT * FROM VIEW_HIRE WHERE ROWNUM<=5;

SELECT ROWNUM, EMPNO, ENAME, HIREDATE FROM (SELECT EMPNO, ENAME, HIREDATE FROM EMP ORDER BY HIREDATE) WHERE ROWNUM<=5;

-- 13- 문제3)
SELECT ROWNUM "RANKING", EMPNO, ENAME, SAL FROM(SELECT EMPNO, ENAME, SAL FROM EMP WHERE SAL IS NOT NULL ORDER BY SAL) WHERE ROWNUM<4;   -- 인라인 뷰 사용시 IS NOT NULL을 있지말고 해주자

CREATE SEQUENCE DEPT_DEPTNO_SEQ INCREMENT BY 10 START WITH 10;
DESC USER_SEQUENCES;
SELECT SEQUENCE_NAME, MIN_VALUE, MAX_VALUE, INCREMENT_BY FROM USER_SEQUENCES;
SELECT DEPT_DEPTNO_SEQ.NEXTVAL FROM DUAL;       -- 10씩 증가
SELECT DEPT_DEPTNO_SEQ.CURRVAL FROM DUAL;       -- 멈춰있음

CREATE SEQUENCE EMP_SEQ START WITH 1 INCREMENT BY 1 MAXVALUE 100000;
SELECT EMP_SEQ.CURRVAL FROM DUAL;
DROP SEQUENCE EMP_SEQ;
DROP TABLE EMP01;

CREATE TABLE EMP01(
EMPNO NUMBER(4) PRIMARY KEY,
ENAME VARCHAR2(10),
HIREDATE DATE);

INSERT INTO EMP01 VALUES(EMP_SEQ.NEXTVAL, '김씨', SYSDATE);

SELECT * FROM EMP01;

SELECT INDEX_NAME, TABLE_NAME, COLUMN_NAME FROM USER_IND_COLUMNS WHERE TABLE_NAME IN('EMP', 'DEPT', 'EMP01');

DROP TABLE EMP01;
CREATE TABLE EMP01 AS SELECT * FROM EMP;
DESC EMP01;
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, STATUS FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMP';
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, STATUS FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMP01';       -- 테이블 복사시 키와 인덱스가 날라감

INSERT INTO EMP01 SELECT * FROM EMP01;
SELECT COUNT(*) FROM EMP01;
INSERT INTO EMP01(EMPNO, ENAME) VALUES(1111,'홍길동');

SELECT DISTINCT EMPNO, ENAME FROM EMP01 WHERE ENAME = '홍길동';

CREATE INDEX IDX_EMP01_ENAME ON EMP01(ENAME);

CREATE TABLE PERSON (NAME VARCHAR2(15), AGE NUMBER(5), REGION VARCHAR2(10));

SELECT*FROM PERSON;
